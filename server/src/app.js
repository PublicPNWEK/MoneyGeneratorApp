import express from 'express';
import bodyParser from 'body-parser';
import { config } from './config.js';
import { IntegrationService } from './integrationService.js';
import { Models } from './models.js';
import { requestLogger } from './logger.js';
import rateLimit from 'express-rate-limit';
import { MetricsService } from './metrics.js';

const app = express();

const publicLimiter = rateLimit({
  windowMs: config.rateLimiting.windowMs,
  max: config.rateLimiting.max,
  standardHeaders: true,
  legacyHeaders: false,
});

const webhookLimiterConfig = {
  windowMs: config.rateLimiting.windowMs,
  max: config.rateLimiting.webhookMax,
  standardHeaders: true,
  legacyHeaders: false,
};
const paypalWebhookLimiter = rateLimit(webhookLimiterConfig);
const plaidWebhookLimiter = rateLimit(webhookLimiterConfig);

app.use(bodyParser.json({ verify: rawBodySaver }));
app.use(requestLogger);
app.use(['/webhooks', '/integrations/plaid'], publicLimiter);

function requireUser(req, res, next) {
  const user = authenticate(req);
  if (!user) {
    req.log.warn('auth_missing_or_invalid');
    return res.status(401).json({ error: 'unauthorized' });
  }
  req.user = user;
  next();
}

function requireAdmin(req, res, next) {
  const user = authenticate(req);
  if (!user || user.role !== 'admin') {
    req.log.warn('admin_required');
    return res.status(403).json({ error: 'forbidden' });
  }
  req.user = user;
  next();
}

function authenticate(req) {
  const authHeader = req.headers.authorization || '';
  const token = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null;
  if (!token) return null;
  if (token === config.auth.adminToken) return { id: 'admin', role: 'admin' };
  if (token === config.auth.userToken) return { id: 'user', role: 'user' };
  return null;
}

app.get('/health', (req, res) => {
  req.log.info('health_check');
  res.json({ status: 'ok', metrics: IntegrationService.getMetrics() });
});

app.post('/integrations/subscribe', (req, res) => {
  const { userId = 'demo-user', planId = 'pro' } = req.body || {};
  const subscription = IntegrationService.createSubscription({
    userId,
    planId,
    correlationId: req.correlationId,
    source: 'subscription_api',
  });
  req.log.info('subscription_created', { userId, planId });
  MetricsService.emitEvent({
    eventType: 'subscription.requested',
    userId,
    correlationId: req.correlationId,
    source: 'subscription_api',
    properties: { planId },
  });
  res.json(subscription);
});

app.post('/integrations/plaid/link-token', (req, res) => {
  // Token generated by backend; client never sees secrets.
  const token = `plaid-sandbox-${Date.now()}`;
  req.log.info('plaid_link_token_issued', { userId: req.body?.userId });
  MetricsService.emitEvent({
    eventType: 'plaid.link_token_issued',
    userId: req.body?.userId || 'demo-user',
    correlationId: req.correlationId,
    source: 'plaid',
  });
  res.json({ link_token: token });
});

app.post('/integrations/plaid/exchange', (req, res) => {
  const { publicToken, userId = 'demo-user' } = req.body || {};
  const itemId = `item-${Date.now()}`;
  Models.plaidItems.set(itemId, { id: itemId, userId, publicToken, accessToken: 'server-only' });
  req.log.info('plaid_public_token_exchanged', { userId, itemId });
  MetricsService.emitEvent({
    eventType: 'plaid.connected',
    userId,
    correlationId: req.correlationId,
    source: 'plaid',
    properties: { itemId },
  });
  res.json({ item_id: itemId });
});

app.post('/webhooks/paypal', paypalWebhookLimiter, (req, res) => {
  try {
    const signature = req.header('x-paypal-signature') || '';
    const timestamp = req.header('x-paypal-transmission-time') || req.requestTimestamp;
    const rawBody = req.rawBody || JSON.stringify(req.body || {});
    const result = IntegrationService.verifyAndProcessPayPalWebhook(
      rawBody,
      signature,
      timestamp,
      req.log,
      req.correlationId,
    );
    res.status(200).json({ status: result.status });
  } catch (err) {
    req.log.error('paypal_webhook_error', { error: err.message });
    res.status(400).json({ error: 'invalid_signature' });
  }
});

app.post('/webhooks/plaid', plaidWebhookLimiter, (req, res) => {
  try {
    const signature = req.header('x-plaid-signature') || '';
    const timestamp = req.header('x-plaid-timestamp') || req.requestTimestamp;
    const rawBody = req.rawBody || JSON.stringify(req.body || {});
    const result = IntegrationService.verifyAndProcessPlaidWebhook(
      rawBody,
      signature,
      timestamp,
      req.log,
      req.correlationId,
    );
    res.status(200).json({ status: result.status });
  } catch (err) {
    req.log.error('plaid_webhook_error', { error: err.message });
    res.status(400).json({ error: 'invalid_signature' });
  }
});

// PayPal billing endpoints (simulated)
app.post('/billing/paypal/subscription/create', requireUser, (req, res) => {
  const { userId = 'demo-user', planId = 'plan_pro' } = req.body || {};
  const result = IntegrationService.createPayPalSubscription({
    userId,
    planId,
    correlationId: req.correlationId,
    log: req.log,
    source: 'paypal_api',
  });
  req.log.info('paypal_subscription_created', { userId, planId });
  res.json(result);
});

app.post('/billing/paypal/subscription/confirm', requireUser, (req, res) => {
  const { providerSubscriptionId, userId = req.user?.id || 'demo-user' } = req.body || {};
  try {
    const sub = IntegrationService.confirmPayPalSubscription({
      providerSubscriptionId,
      userId,
      correlationId: req.correlationId,
      log: req.log,
    });
    const entitlement = IntegrationService.createEntitlement({
      userId,
      correlationId: req.correlationId,
      source: 'paypal_api',
    });
    const entitlement = IntegrationService.createEntitlement({
      userId: req.user?.id || userId,
      productId: sub.planId,
      kind: 'plan',
      durationDays: 30,
    });
    res.json({ subscription: sub, entitlement });
  } catch (e) {
    res.status(400).json({ error: e.message });
  }
});

app.post('/billing/paypal/subscription/cancel', requireUser, (req, res) => {
  const { providerSubscriptionId } = req.body || {};
  try {
    const sub = IntegrationService.cancelPayPalSubscription({
      providerSubscriptionId,
      correlationId: req.correlationId,
      log: req.log,
      source: 'paypal_api',
    });
    res.json({ subscription: sub });
  } catch (e) {
    res.status(400).json({ error: e.message });
  }
});

app.post('/outbound/dispatch', requireAdmin, async (req, res) => {
  await IntegrationService.dispatchOutboundWebhooks(req.log);
  res.json({ status: 'ok', queueLength: Models.outboundWebhookQueue.length });
});

function rawBodySaver(req, res, buf) {
  req.rawBody = buf.toString();
}

export default app;

// Catalog and entitlement helpers
const catalog = [
  {
    id: 'plan_pro',
    type: 'plan',
    name: 'Pro Plan',
    price: '$14.99/mo',
    description: 'Advanced analytics, instant payouts, and automation.',
  },
  {
    id: 'addon_shift_insights',
    type: 'addon',
    name: 'Shift Insights',
    price: '$4.99/mo',
    description: 'Per-shift profitability and mileage rollups.',
  },
  {
    id: 'onetime_boost',
    type: 'one_time',
    name: 'Boost Pack',
    price: '$19.99',
    description: 'Priority placement for 14 days.',
  },
];

app.get('/catalog', (req, res) => {
  MetricsService.emitEvent({
    eventType: 'shop.viewed',
    userId: 'demo-user',
    correlationId: req.correlationId,
    source: 'shop',
    properties: { surface: 'catalog' },
  });
  res.json({ products: catalog });
});

app.get('/entitlements', (req, res) => {
  const userId = req.query.userId || 'demo-user';
  const entitlements = Array.from(Models.entitlements.values()).filter(
    e => e.userId === userId,
  );
  res.json({ entitlements });
});

app.post('/purchase', (req, res) => {
  const { productId, userId = 'demo-user' } = req.body || {};
  const product = catalog.find(p => p.id === productId);
  if (!product) {
    return res.status(400).json({ error: 'unknown_product' });
  }
  const entitlement = IntegrationService.createEntitlement({
    userId,
    productId,
    kind: product.type,
    durationDays: product.type === 'one_time' ? 0 : 30,
  });
  req.log.info('purchase_completed', { userId, productId });
  MetricsService.emitEvent({
    eventType: 'checkout.completed',
    userId,
    correlationId: req.correlationId,
    source: 'shop',
    properties: { productId, productType: product.type },
  });
  res.json({ entitlement });
});

app.post('/metrics/events', (req, res) => {
  try {
    const { eventType, userId = 'demo-user', ts, properties = {}, correlationId, source } =
      req.body || {};
    const result = MetricsService.emitEvent({
      eventType,
      userId,
      ts,
      properties,
      source: source || 'app',
      correlationId: correlationId || req.correlationId,
    });
    res.json(result);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

app.post('/metrics/rollup/daily', (req, res) => {
  const { asOf } = req.body || {};
  const result = MetricsService.generateDailyRollups(asOf ? new Date(asOf) : new Date());
  res.json(result);
});

app.get('/metrics/rollup/daily', (req, res) => {
  const userId = req.query.userId || 'demo-user';
  const date = req.query.date;
  const rollup = MetricsService.getDailyRollup({ userId, date });
  if (!rollup) {
    MetricsService.generateDailyRollups(date ? new Date(date) : new Date());
  }
  const refreshed = MetricsService.getDailyRollup({ userId, date });
  res.json({ rollup: refreshed });
});
